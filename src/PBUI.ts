// PBUI.ts
//
// This class is the user interface to the app.
// In standard mode it only shows the graves, a way to select
// the cemetery and a way to enter a filter string.  THe graves
// are shown in a scrollable table.
//
// There is an edit button that will bring up a password dialog.
// A collection of controls, mostly buttons, show up beneath
// the graves table.  Clicking on a row will open it for editing.
// Only a selected row can be deleted.  A grave can be added one
// at a time, or the disabled import can be used for bulk additions.


import {GraveInfo, GraveState, SerializableGrave} from './PBInterfaces.js';
import {PBGrave} from './PBGrave.js';
import {PBCemetery} from './PBCemetery.js';
import {PBColumbarium} from './PBColumarium.js';
import {PBFace} from './PBFace.js';
import {PBRow} from './PBRow.js';
import {PBConst} from './PBConst.js';
import {PBGraveSearch} from "./PBGraveSearch.js";
import {PBOcclusion} from "./PBOcclusion.js";
import {PBAddGrave} from "./PBAddGrave.js";
import {PBOptions} from "./PBOptions.js";
import {PBPlot} from "./PBPlot";

class PBUI {
    controlDiv: HTMLDivElement;     // The main div of the control.  Passed to map.controls.

    boundingDiv: HTMLDivElement;    // Child of controlDiv.  Actually holds everything.
    selectElement: HTMLSelectElement;   // Drop down list of cemetery names.
    searchElement: HTMLInputElement;    // Text to use as a filter.

    editDiv: HTMLDivElement;        // Holds all of the edit controls.  Initially hidden.
    importElement: HTMLTextAreaElement;   // Used to input text to be imported

    savingOcclusion: PBOcclusion;   // Covers the controlDiv while saving.  Ends with an OK button.
    addGraveOcclusion: PBAddGrave;  // Covers the controlDiv while adding a grave.  Ends with an OK button.
    optionsOcclusion: PBOptions;    // Covers the controlDiv while editing the options.  Ends with an OK button.

    graveSearch: PBGraveSearch;     // Deals with all of the grave manipulation
    editing: boolean = false;       // Editing defaults to false.

    constructor(public map: google.maps.Map, public cemeteries: Array<PBCemetery>) {
        this.graveSearch = new PBGraveSearch(map, cemeteries);
        this.initElements();
        this.initEventListeners();
    }

    buildIcon(theIcon: string, theId: string, theEvent: string, theToolTip: string) {
        // Given the passed parameters, build the HTML for a icon
        // with a tooltip that fires an event.
        return(`  <i class="icon ion-md-${theIcon}" id="${theId}" style="font-size: 16px"
                                            onclick="window.dispatchEvent(new Event('${theEvent}'));">
                                            <span class="tooltip">${theToolTip}</span>
                                        </i>`);
    }

    initElements() {
        // The main div
        this.controlDiv = document.createElement('div') as HTMLDivElement;
        this.controlDiv.className = 'control-div';
        this.controlDiv.style.position = 'absolute';
        this.savingOcclusion = new PBOcclusion(this.controlDiv);
        this.addGraveOcclusion = new PBAddGrave(this.controlDiv);
        this.optionsOcclusion = new PBOptions(this.controlDiv);

        // Bounding is sibling to occlusion
        this.boundingDiv = document.createElement('div') as HTMLDivElement;
        this.controlDiv.appendChild(this.boundingDiv);
        this.boundingDiv.className = 'bounding-div';

        // The standard search controls
        this.selectElement = document.createElement('select');
        this.boundingDiv.appendChild(this.selectElement);
        this.selectElement.id = 'cemetery-select';
        this.selectElement.innerHTML = this.buildCemeteryListHTML();
        this.searchElement = document.createElement('input');
        this.boundingDiv.appendChild(this.searchElement);
        this.searchElement.type = 'text';
        this.searchElement.id = 'cemetery-search';
        this.searchElement.style.width = '75px';
        this.searchElement.placeholder = "Search...";

        // Icons with tooltips
        this.boundingDiv.innerHTML += `<div style="position: absolute; right -20px;">`;
        this.boundingDiv.innerHTML += this.buildIcon('create', 'edit-icon', PBConst.EVENTS.requestPassword, "Edit");
        this.boundingDiv.innerHTML += this.buildIcon('settings', 'settings-icon', PBConst.EVENTS.openOptions, "Settings");
        this.boundingDiv.innerHTML += this.buildIcon('document', 'report-icon', PBConst.EVENTS.printReport, "Report");
        this.boundingDiv.innerHTML += this.buildIcon('help', 'help-icon', PBConst.EVENTS.openHelp, "Help");
        this.boundingDiv.innerHTML += `</div`;

        // The actual table is generated by graveSearch
        this.graveSearch.appendTableAndWarning(this.boundingDiv);

        // The edit controls.  Default to display of none.
        this.editDiv = document.createElement('div');
        this.boundingDiv.appendChild(this.editDiv);
        this.editDiv.className = 'edit-div';
        this.editDiv.innerHTML = `  <button type="button" style="display: none;" onclick="window.dispatchEvent(new Event('${PBConst.EVENTS.importGraves}'));">Import Graves</button>
                                    <button type="button" id="delete-button" disabled onclick="window.dispatchEvent(new Event('${PBConst.EVENTS.deleteGrave}'));">Delete Grave</button>
                                    <button type="button" id="add-button" onclick="window.dispatchEvent(new Event('${PBConst.EVENTS.openAddGraveUI}'));">Add Grave</button>
                                    <button type="button" id="save-button" onclick="window.dispatchEvent(new Event('${PBConst.EVENTS.postJSON}'));">Save</button>
                                    <button type="button" class="close-button" onclick="window.dispatchEvent(new Event('${PBConst.EVENTS.closeEditControls}'));">Close</button>`;
        this.importElement = document.createElement('textarea');
        this.importElement.style.display = 'none';
        this.editDiv.appendChild(this.importElement);

        this.map.controls[google.maps.ControlPosition.TOP_CENTER].push(this.controlDiv);
    }

    initEventListeners() {
        window.addEventListener(PBConst.EVENTS.postJSONResponse, (event: CustomEvent) => {this.onSaveFinished(event);});
        window.addEventListener(PBConst.EVENTS.importGraves, (event: CustomEvent) => {this.onImportGraves();});
        window.addEventListener(PBConst.EVENTS.requestPassword, (event: CustomEvent) => {this.onRequestPassword();});
        window.addEventListener(PBConst.EVENTS.closeEditControls, (event: CustomEvent) => {this.onCloseEditControls();});
        window.addEventListener(PBConst.EVENTS.selectGraveRow, (event: CustomEvent) => {this.onRowSelected(event);});
        window.addEventListener(PBConst.EVENTS.unselectGraveRow, (event: CustomEvent) => {this.onRowUnselected(event);});
        window.addEventListener(PBConst.EVENTS.isDirty, () => {this.enableSaveButton(true);});
        window.addEventListener('input', (event: InputEvent) => {this.onInput(event)});
        window.addEventListener(PBConst.EVENTS.openOptions, (event: CustomEvent) => {this.onOpenOptions(event);});
        window.addEventListener(PBConst.EVENTS.closeOptions, (event: CustomEvent) => {this.onCloseOptions(event);});
        window.addEventListener(PBConst.EVENTS.openAddGraveUI, (event: CustomEvent) => {this.onOpenAddGrave(event);});
        window.addEventListener(PBConst.EVENTS.closeAddGraveUI, (event: CustomEvent) => {this.onCloseAddGraveUI(event);});
        window.addEventListener(PBConst.EVENTS.requestCemeteryNames, (event: CustomEvent) => {this.onRequestCemeteryNames(event);});
        window.addEventListener(PBConst.EVENTS.printReport, (event: CustomEvent) => {this.onPrintReport(event);});
        window.addEventListener(PBConst.EVENTS.openHelp, (event: CustomEvent) => {this.onOpenHelp(event);})
    }

    enableSaveButton(enable: boolean) {
        (document.getElementById('save-button') as HTMLButtonElement).disabled = !enable;
        window.addEventListener('beforeunload', this.lastChanceToSave, {capture: true});    // To avoid problems with the Back-Forware cache,// Only use EventListener when needed.
    }

    onInput(event: InputEvent) {
        // Input from the cemetery select and the filter control.
        let theElement = event.target as any;
        if (theElement.id == 'cemetery-select') {
            let cemeteryIndex = theElement.selectedIndex - 1;   // The drop down list starts with "All Cemeteries"
            if (cemeteryIndex >= 0)
                this.cemeteries[cemeteryIndex].zoomCemetery();
            this.graveSearch.populateTable(cemeteryIndex);
            // For some reason, cannot use this.searchElement.  The id looks
            // correct, but it has a different value.
            this.graveSearch.filterByTextAndState((document.getElementById('cemetery-search') as HTMLInputElement).value);
        } else if (theElement.id == 'cemetery-search') {
            this.graveSearch.populateTable(this.graveSearch.populateIndex);
            let theText = (event.target as HTMLInputElement).value.toLowerCase();
            this.graveSearch.filterByTextAndState(theText);
        }
    }

    onRequestPassword(){
        let password = prompt("Enter the password.");
        if (password == 'lunchlady') {
            this.editing = true;
            this.editDiv.style.display = 'block';   // Show the controls.
            this.graveSearch.edit = true;
            (document.getElementById('save-button')  as HTMLInputElement).disabled = !this.graveSearch.isDirty;
            document.getElementById('edit-icon').style.display = 'none';
        } else {
            alert('Invalid password.  Access denied.');
        }
    }

    onCloseEditControls() {
        this.editing = false;   // Disable editing.
        this.graveSearch.edit = false;
        this.editDiv.style.display = 'none';    // Hide the edit controls.
        document.getElementById('edit-icon').style.display = 'initial';
        this.disableDeleteButton(true);
        this.lastChanceToSave();
    }

    lastChanceToSave() {
        // Additional chance to save
        if (this.graveSearch.isDirty) {
            if (confirm('Changes have been made.  Do you want to save them?'))
                window.dispatchEvent(new Event(PBConst.EVENTS.postJSON));
        }
        window.removeEventListener('beforeunload', this.lastChanceToSave, {capture: true}); // Protects the Back-Forward cache.
    }

    buildCemeteryListHTML(): string {
        // The options for the drop down cemetery list.
        let selectOptions: string = '<option value="-1">All Cemeteries</option>';
        this.cemeteries.forEach((cemetery, index) => {
            selectOptions += '<option value="' + index + '">' + cemetery.name + '</option>';} );
        return(selectOptions);
    }

    onSaveInitiated() {
        this.savingOcclusion.activate('Saving, please wait.');
        this.graveSearch.closeRowEdit();
    }

    onSaveFinished(event: CustomEvent) {
        // Show the result of the save and demand an OK.
        let status = 'Save Successful';
        if (!event.detail.success) {
            status = `Save Failed<div style="font-size: 16px;">${event.detail.message}</div>`;
        } else {
            this.graveSearch.isDirty = false;
            this.enableSaveButton(false);
        }
        this.savingOcclusion.setText(status);
        this.savingOcclusion.showOKButton();
    }

    onOpenOptions(event: CustomEvent) {
        this.optionsOcclusion.activate('Activated');
        this.optionsOcclusion.showOKButton();
    }

    onCloseOptions(event: CustomEvent) {
        this.optionsOcclusion.deactivate();
    }

    onOpenAddGrave(event: CustomEvent) {
        this.addGraveOcclusion.activate('Activated');
        this.addGraveOcclusion.showOKButton();
    }

    onCloseAddGraveUI(event: CustomEvent) {
        this.addGraveOcclusion.deactivate();
    }

    onRequestCemeteryNames(event: CustomEvent) {
        let theNames: Array<string> = [];
        this.cemeteries.forEach((theCemetery) =>{theNames.push(theCemetery.name);});
        window.dispatchEvent(new CustomEvent(PBConst.EVENTS.cemeteryNamesResponse, {detail: {names: theNames}}))
    }

    onImportGraves() {
        // Only supports a very simple import of
        // name and date pairs.
        // The first line of the pair is a \n terminated string with the full name.
        // The second line is a \n terminated string with some type of date.
        // The date is only stored as a string and is not validated in any way.
        let theCemetery: PBCemetery = this.cemeteries[this.selectElement.selectedIndex];
        let textToImport: string = this.importElement.value;
        textToImport += '\n';   // Just in case
        let textArray = textToImport.split('\n');

        for (let index = 0; index < textArray.length; index += 2) {
            let theGrave = new PBGrave({name: textArray[index], dates: textArray[index + 1], state: GraveState.Interred} as SerializableGrave);
            if (theGrave.validGrave)
                theCemetery.addGraves(theGrave);
        }
    }

    disableDeleteButton(disable: boolean) {
        let theButtonElement = document.getElementById('delete-button') as HTMLInputElement;
        theButtonElement.disabled = disable;
    }

    onRowUnselected(event: CustomEvent) {
        if (this.editing) {
            this.disableDeleteButton(true);
        }
    }

    onRowSelected(event: CustomEvent) {
        if (this.editing) {
            this.disableDeleteButton(false);
        } else {
            let graveInfo: GraveInfo = this.graveSearch.graveInfoByRowIndex(event.detail.index);
            this.cemeteries[graveInfo.cemeteryIndex].zoomCemetery();
            this.cemeteries.forEach((theCemetery, theIndex) => {
                if (theIndex == graveInfo.cemeteryIndex)
                    theCemetery.showDirectionsToGrave(graveInfo);
                else
                    theCemetery.hideDirectionsToGrave();
            });
        }
    }

    htmlCemeteryHeader(theCemetery: PBCemetery) : string {
        // Generate the HTML for the cemetery table, the stats and the header.
        let theHTML = `<table class="cemetery-table">
                            <caption>
                                <span class="cemetery-title">${theCemetery.name + ' Cemetery'}</span><br>
                                <span class="cemetery-stats">${theCemetery.getStats()}</span>
                            </caption>
                            <tr class="cemetery-header">
                                <th>Plot</th><th>Grave</th><th>Name</th><th>Dates</th>
                            </tr>`;
        return(theHTML);
    }

    htmlUnassignedGraves(theCemetery: PBCemetery) : string {
        // Generate the HTML for all of the unassigned graves in a cemetery.
        let theHTML: string = '';

        theCemetery.graves.forEach((theGrave: PBGrave, theIndex: number) => {
            if (theIndex == 0) {
                theHTML += `<tr class="first-grave-in-plot">
                                    <td class="plot-row" rowspan="${theCemetery.graves.length}" colspan="2">Unassigned</td>`
            } else {
                theHTML += (theIndex % 2) ? `<tr class="odd-grave">` : `<tr class="even-grave">`; // Alternating bands
            }
            theHTML += `<td class="name-column">${theGrave.name}</td><td class="dates-column">${theGrave.dates}</td>
                        </tr>`;
        });
        return(theHTML);
    }

    htmlGravesInAPlot(thePlot: PBPlot) : string {
        // Generate the HTML for all of the graves in this plot.  Note that some or all of the
        // graves in the plot are unassigned.
        let theHTML: string = '';
        for (let graveIndex = 0; graveIndex < thePlot.numGraves; graveIndex++) {
            let theGrave: PBGrave = thePlot.graves[graveIndex];
            if (graveIndex == 0) {
                theHTML += `<tr class="first-grave-in-plot">
                                        <td class="plot-row plot-column" rowspan="${thePlot.numGraves}">${thePlot.id}</td>`
            } else {
                theHTML += (graveIndex % 2) ? `<tr class="odd-grave">` : `<tr class="even-grave">`; // Alternating bands
            }
            theHTML += `<td class="grave-in-plot grave-column">${graveIndex + 1}</td>`;
            if (theGrave) {   // An actual grave
                theHTML += `<td class="name-column">${theGrave.name}</td><td class="dates-column">${theGrave.dates}</td>`;
            } else {    // This grave unassigned
                theHTML += `<td></td><td></td>`;
            }
            theHTML += `</tr>`;
        }
        return(theHTML);
    }

    totalRowsForColumbarium(theColumbarium: PBColumbarium) : number {
        // Calculate the total number of rows in the table that the columbarium
        // will need.
        let totalRows: number = 0;
        theColumbarium.faces.forEach((theFace: PBFace) => {
            totalRows++;    // Name of the columbarium and the face
            theFace.rows.forEach((theRow: PBRow) =>{
                totalRows++;    // Name of the row
                totalRows += theRow.graves.length;
            });
        });
        return(totalRows);
    }

    htmlFace(theFace: PBFace) : string {
        // Generate the HTML for a face of the columbarium.
        // The <tr> is already present.
        let theHTML: string = `<td class="columbarium-title" colspan="3">${theFace.columbariumName}, ${theFace.faceName}</td></tr>`;
        theFace.rows.forEach((theRow: PBRow) => {
            theHTML += `<tr><td class="row-title" colspan="3">${theRow.name}</td></tr>`;
            for (let index: number = 0; index < theRow.graves.length; index++) {
                let theGrave: PBGrave = theRow.graves[index];
                if (index == 0) {
                    theHTML += `<tr class="first-grave-in-plot even-grave">`;
                } else {
                    theHTML += (index % 2) ? `<tr class="odd-grave">` : `<tr class="even-grave">`; // Alternating bands
                }
                theHTML += `<td class="grave-in-plot grave-column">${index + 1}${(theRow.urns[index] == 1) ? 'S' : 'D'}</td>`;  // Niche number and single/double status

                if (theGrave) {
                    theHTML += `<td class="name-column">${theGrave.name}</td><td class="dates-column">${theGrave.dates}</td>`;
                } else {    // This grave unassigned
                    theHTML += `<td></td><td></td>`;
                }
                theHTML += `</tr>`;
            };
        });
        return(theHTML);
    }

    htmlColumbarium(thePlot: PBPlot) : string {
        // Generate the HTML for the columbarium.
        let theHTML: string = `<tr><td class="plot-row plot-column" rowspan="${this.totalRowsForColumbarium(thePlot.columbarium)}">${thePlot.id}</td>`;
        thePlot.columbarium.faces.forEach((theFace: PBFace, index: number) => {
            theHTML += (index != 0) ? '<tr>' : '';
            theHTML += this.htmlFace(theFace);
        });
        return(theHTML);
    }

    onPrintReport(event: CustomEvent) {
        // Display all of the graves, by cemetery, in a new tab.
        let handle = window.open('', '_blank');
        // Start the document.
        let theHTML = `
            <!DOCTYPE html>
            <html>
              <head>
                <meta name="viewport" content="initial-scale=1.0, user-scalable=no">
                <meta charset="utf-8">
                <title>List of Graves by Cemetery</title>
                <link rel="stylesheet" href="css/grave-list.css">
              <body>`;  // The warning that this directory cannot be found is because this html will be executed
                        // from the root and not from this directory.

        this.cemeteries.forEach((theCemetery: PBCemetery) => {
            theHTML += this.htmlCemeteryHeader(theCemetery);    // Start the table.
            theHTML += this.htmlUnassignedGraves(theCemetery);

            // Graves or columbarium in the plot
            theCemetery.plots.forEach((thePlot: PBPlot) => {
                if (thePlot.columbarium) {
                    theHTML += this.htmlColumbarium(thePlot);
                } else {
                    theHTML += this.htmlGravesInAPlot(thePlot);
                }
            });

            // Finish off the table.
            theHTML += `</table><br><br>`;
        });

        // Finish off the document.
        theHTML += `
              </body>
            </html>`;
        handle.document.write(theHTML);
    }

    onOpenHelp(event: CustomEvent) {
        // Display the help in a new tab.
        let handle = window.open('', '_blank');
        // Start the document.
        // Warnings that the directories cannot be found in the link and img elements
        // are because the html will be run from the root and not from
        // the source or built directories.
        let theHTML = `
            <!DOCTYPE html>
            <html>
                <head>
                    <meta name="viewport" content="initial-scale=1.0, user-scalable=no">
                    <meta charset="utf-8">
                    <title>Help for Grave Finder</title>
                    <link href="css/help.css" rel="stylesheet" >
                    <link href="css/myicons.css" rel="stylesheet">
                </head>
                <body>
                    <h2 class="help-title">Grave Finder Help</h2>
                    <p>Grave Finder is an app used for searching and displaying the graves in the four cemeteries maintained by 
                        St. Bernard Catholic Church in Beverly, OH and St. James Catholic Church in McConnelsville, OH.  This app is an interface placed on top of Google Maps.</p>
                    <p>These cemeteries are:
                        <ul>
                            <li>St. Bernard in Beverly, OH</li>
                            <li>St. Margaret in Hackney, OH</li>
                            <li>St. Margaret on the Knoll in Hackney, OH</li>
                            <li>St. Barnabas in Deavertown, OH</li>
                        </ul>
                        Hovering over a marker will give the name of the cemetery.  Double clicking on the marker will zoom to that cemetery.
                    </p>
                    <img src="./assets/interface.png">
                    <p>To find a grave, just start typing the name in the <code>Search...</code> box.  This text will be matched to the names and dates associated with the grave.  Multiple graves at multiple cemeteries may match your search text.
                        For example, typing in <code>mar</code> will find the names <code>Mary, Maria</code> and <code>Demartin</code>.
                        To limit your search to only one cemetery, choose from the drop down list to the left of <code>Search...</code>
                    </p>
                    <p>When you click on a name, the map will zoom to that cemetery.  It will then give you directions to the grave from the cemetery landmark.</p>
                    <p>To the right of <code>Search...</code>Are some icons that perform the following functions:</p>
                    <table class="icon-table">
                       <tr><td><i class="icon ion-md-create" ></i></td><td>Click here to edit the data.  You'll need a password.</td></tr> 
                       <tr><td><i class="icon ion-md-settings" ></i></td><td>Click here to change the options.</td></tr> 
                       <tr><td><i class="icon ion-md-document" ></i></td><td>Click here to open a separate tab with a report with all of the graves for all of the cemeteries</td></tr> 
                       <tr><td><i class="icon ion-md-help" ></i></td><td>Click here to display this help.</td></tr> 
                    </table>
                    <p><br>Release 0.7.2</p>
                </body>
            </html>`;
        handle.document.write(theHTML);
    }

}

export {PBUI};